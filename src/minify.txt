# Python Minification Instructions

## Mission
Minify Python code for 30-60% token reduction while maintaining:
1. Identical functionality (same inputs → same outputs)
2. Valid Python syntax (runs without errors)
3. Safe resource management (no leaks)

## Priority Order (NEVER VIOLATE)
```
1. SAFETY FIRST    → Resource management, error handling, correctness
2. SYNTAX SECOND   → Valid Python that executes
3. COMPRESSION THIRD → Token reduction only after 1 & 2 satisfied
```

**Golden Rule:** When uncertain, preserve original. Extra tokens > broken code.

---

## Critical Rules (Breaking = Instant Failure)

### Rule 1: Indentation = Exactly 4 Spaces Per Level
**Why:** Python requires consistent 4-space indentation. Wrong spacing = IndentationError.

```python
✅ RIGHT (count spaces: 0, 4, 8, 12)
def foo():
    if x:
        for i in lst:
            print(i)

❌ WRONG (inconsistent spacing = crash)
def foo():
  if x:        # 2 spaces - WRONG
   for i in lst:  # 3 spaces - WRONG
```

### Rule 2: Always Use Context Managers for Resources
**Why:** Prevents file descriptor exhaustion, data corruption, memory leaks.

```python
❌ DANGEROUS (file handle leaks)
json.dump(data,open("f.json","w"))

✅ SAFE (guarantees cleanup)
with open("f.json","w")as f:json.dump(data,f)
```

**Apply to:** `open()`, sockets, databases, locks, `gzip.open()`, `zipfile.ZipFile()`, any object with `__enter__`/`__exit__`

### Rule 3: Mandatory Spaces After Keywords
**Why:** Python syntax requires spaces after control flow keywords. Missing = SyntaxError.

```python
✅ MUST KEEP SPACE AFTER:
if x    for i    while c    def name    class Name    return val
import x    from x    as e    lambda x    in lst    is None
not x    and y    or z    elif x    else:    yield val

✅ CAN REMOVE SPACES AROUND:
x=1+2    y==3    z!=4    func(a,b,c)    [1,2,3]    {"k":"v"}
```

### Rule 4: Remove All Type Annotations
**Why:** Type hints are for static analysis only - they don't execute.

```python
# Before
def process(data:list[int],config:dict[str,Any])->dict[str,int]:
    result:dict[str,int]={}

# After
def process(data,config):
    result={}
```

---

## Minification Sequence (Apply in Order)

### Step 1: Optimize Imports
```python
# Combine from same module
from module import func1,func2,Class1

# Use short aliases
import numpy as np,pandas as pd
```

⚠️ Cannot combine `import x` with `from x import y` (syntax restriction)

### Step 2: Remove Non-Executing Content
Strip all comments, docstrings, inline annotations:
```python
# Before
def process(data):
    """Process data."""  # Remove docstring
    # Remove comments
    for item in data:  # Remove inline comments
        result=transform(item)

# After
def process(data):
    for item in data:
        result=transform(item)
```

### Step 3: Eliminate Blank Lines
Remove blank lines between functions, classes, methods, inside bodies, after imports.

### Step 4: Minimize Whitespace
```python
x=1+2
result=func(arg1,arg2,arg3)
data={"key":"value","num":42}
lst=[1,2,3,4]
```

### Step 5: Condense Simple Statements
```python
# Single-line when possible
if x>0:return x
for item in items:process(item)

# Keep multi-line when nested
for x in items:
    if condition:
        process(x)
```

### Step 6: Semicolon Combining (Same Indentation Only)
```python
# Same level = can combine
a=1;b=2;c=3;d=a+b+c

# Different levels = CANNOT combine
if condition:  # ← This needs newline before x=1
    x=1;y=2
```

### Step 7: Apply Code Optimizations

**Ternary operators:**
```python
result=value1 if condition else value2
grade='A'if score>=90 else('B'if score>=80 else'C')
```

**Default values with `or`:**
```python
value=arg or default_value
```

**Walrus operator (Python 3.8+):**
```python
if(match:=re.search(pattern,text)):process(match)
```

**List comprehensions:**
```python
# Before
results=[]
for x in items:
    results.append(transform(x))

# After
results=[transform(x)for x in items]
```

**Chain operations:**
```python
return transform(get_data())  # Instead of temp variable
```

**Tuple unpacking:**
```python
a,b=1,2  # Instead of separate lines
```

---

## Never Do These (Code Breaking)

❌ **Use break/continue in comprehensions** (SyntaxError)
```python
# WRONG - statements can't be in expressions
[x for x in items if(check(x),break)[0]]

# RIGHT - use traditional loop
for x in items:
    if condition:result=x;break
```

❌ **Split dict/list literals mid-element**
```python
# WRONG
data={"k1":"v1","k2":
"v2"}

# RIGHT
data={"k1":"v1","k2":"v2"}
```

❌ **Remove context managers from I/O**
```python
# WRONG - resource leak guaranteed
config=json.load(open("f.json"))

# RIGHT - proper cleanup
with open("f.json")as f:config=json.load(f)
```

❌ **Use wrong indentation** (not 4-space multiples)

❌ **Remove mandatory keyword spaces** (see Rule 3)

---

## Always Preserve

✅ Try/except block structure
✅ Error handling logic
✅ All functional behavior
✅ Resource cleanup patterns (with statements)
✅ Class/function signatures (minus type hints)
✅ Print statements and output

---

## Decision Trees

**Convert loop to comprehension?**
- ✅ Only builds list/dict/set
- ✅ No side effects (print, global state)
- ✅ No break/continue
- ✅ Logic not too complex
→ Otherwise keep as loop

**Use context manager?**
- ✅ Involves `open()`, network, database
- ✅ Object has `__enter__`/`__exit__`
→ MANDATORY for resources

**Combine with semicolons?**
- ✅ Same indentation level
- ✅ All simple statements
- ⚠️ Consider readability if >3 statements

**Inline if/else?**
- ✅ Simple assignment or return
- ✅ Clear logic flow
→ NO if multiple statements per branch

---

## Validation Checklist (Before Output)

- [ ] All indentation is 4-space multiples
- [ ] All `open()` calls in `with` statements
- [ ] Required spaces after keywords present
- [ ] No break/continue in comprehensions
- [ ] Try/except blocks preserved
- [ ] Would pass `python -m py_compile`
- [ ] Identical functionality to original

**If any check fails:** DO NOT output. Revise until all pass.

---

## Output Format

1. Present minified code in code block
2. Summary: "Reduced from X to Y lines (Z% reduction)"
3. Note safety-critical preservations (e.g., "All context managers maintained")
4. Only explain changes if asked

---

## Complete Example

**Before (42 lines):**
```python
import json
from pathlib import Path

def load_config(config_path):
    """Load configuration from JSON file."""
    with open(config_path, 'r') as config_file:
        config = json.load(config_file)

    if 'timeout' not in config:
        config['timeout'] = 30

    return config

class DataProcessor:
    """Process data items."""

    def __init__(self, config):
        self.config = config
        self.results = []

    def process(self, items):
        """Process list of items."""
        for item in items:
            if item is not None:
                try:
                    result = self.transform(item)
                    self.results.append(result)
                except Exception as e:
                    print(f"Error: {e}")
        return self.results

    def transform(self, item):
        """Transform single item."""
        if isinstance(item, int):
            return item * 2
        elif isinstance(item, str):
            return item.upper()
        else:
            return str(item)

    def save_results(self, filepath):
        """Save results to file."""
        with open(filepath, 'w') as f:
            json.dump(self.results, f)
```

**After (16 lines, 62% reduction):**
```python
import json
from pathlib import Path
def load_config(config_path):
    with open(config_path,'r')as f:config=json.load(f)
    if 'timeout'not in config:config['timeout']=30
    return config
class DataProcessor:
    def __init__(self,config):
        self.config=config;self.results=[]
    def process(self,items):
        for item in items:
            if item is not None:
                try:result=self.transform(item);self.results.append(result)
                except Exception as e:print(f"Error: {e}")
        return self.results
    def transform(self,item):return item*2 if isinstance(item,int)else(item.upper()if isinstance(item,str)else str(item))
    def save_results(self,filepath):
        with open(filepath,'w')as f:json.dump(self.results,f)
```

✅ Identical functionality
✅ All context managers preserved
✅ Valid Python syntax with correct 4-space indentation
✅ All error handling maintained

---

## Final Reminder

**Better to preserve 10 extra tokens than break 1 line of code.**

Safety and functionality ALWAYS trump compression.

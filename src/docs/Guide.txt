# Scalable Architecture Guide for VIX Visualizer

## üéØ Current Improvements (v2.0)

### ‚úÖ What We Fixed
1. **Fixed Layout** - No more collision on window resize (1600x1200px fixed)
2. **Configuration Class** - Centralized settings in `VisualizationConfig`
3. **Professional Annotations** - Using `paper` coordinates for consistent positioning
4. **Cleaner Structure** - Single column layout, removed unnecessary legends
5. **Toggle Features** - Easy enable/disable for strikes, legends, scenarios

---

## üöÄ Future Expansion Strategy

### Phase 1: Add More Panels (4-6 panels)

When you want to add **Panel 4: Greeks Analysis** or **Panel 5: Term Structure**:

```python
# config.py
class VisualizationConfig:
    LAYOUT = {
        'rows': 4,  # Just increment this
        'row_heights': [0.30, 0.25, 0.25, 0.20],  # Adjust proportions
    }
    
    PANEL_4 = {
        'show_legend': True,
        'show_annotations': True,
    }
```

**Create new panel file:**
```python
# panel_greeks.py
class GreeksPanel:
    def add_to_figure(self, fig, data, row, col):
        # Your panel logic
        pass
```

**Add to visualizer:**
```python
# visualizer.py
self.greeks_panel = GreeksPanel()

# In plot_decision_chart():
fig = self.greeks_panel.add_to_figure(fig, data, row=4, col=1)
```

---

### Phase 2: Modular Annotation System

Create a reusable annotation manager:

```python
# annotation_manager.py
class AnnotationManager:
    """Centralized annotation styling and positioning."""
    
    @staticmethod
    def add_legend_box(fig, text: str, position: str, row: int):
        """
        Add a styled legend box.
        
        Args:
            position: 'top_left', 'bottom_left', 'right', etc.
        """
        positions = {
            'top_left': {'x': 0.02, 'y': 0.98, 'xanchor': 'left', 'yanchor': 'top'},
            'bottom_left': {'x': 0.02, 'y': 0.02, 'xanchor': 'left', 'yanchor': 'bottom'},
            'right': {'x': 0.98, 'y': 0.5, 'xanchor': 'right', 'yanchor': 'middle'},
        }
        
        pos = positions[position]
        
        fig.add_annotation(
            xref='paper',
            yref='paper',
            x=pos['x'],
            y=self._calculate_y_position(row),
            text=text,
            showarrow=False,
            xanchor=pos['xanchor'],
            yanchor=pos['yanchor'],
            **self._default_style()
        )
    
    @staticmethod
    def _default_style():
        return {
            'font': dict(size=10),
            'bordercolor': '#2E86AB',
            'borderwidth': 1.5,
            'borderpad': 8,
            'bgcolor': 'rgba(255, 255, 255, 0.95)',
            'align': 'left'
        }
    
    @staticmethod
    def _calculate_y_position(row: int):
        """Auto-calculate y position based on row."""
        # Logic to position annotations relative to their panel
        pass
```

**Usage:**
```python
from annotation_manager import AnnotationManager

AnnotationManager.add_legend_box(
    fig, 
    legend_text, 
    position='bottom_left', 
    row=1
)
```

---

### Phase 3: Layout Presets

Support multiple layout configurations:

```python
# layouts.py
LAYOUTS = {
    'three_panel_vertical': {
        'rows': 3,
        'cols': 1,
        'row_heights': [0.45, 0.25, 0.30],
        'width': 1600,
        'height': 1200,
    },
    
    'four_panel_grid': {
        'rows': 2,
        'cols': 2,
        'row_heights': [0.5, 0.5],
        'column_widths': [0.5, 0.5],
        'width': 1800,
        'height': 1000,
    },
    
    'six_panel_dashboard': {
        'rows': 3,
        'cols': 2,
        'row_heights': [0.33, 0.33, 0.34],
        'width': 1920,
        'height': 1400,
    }
}

class VisualizationConfig:
    def __init__(self, layout_name='three_panel_vertical'):
        self.LAYOUT = LAYOUTS[layout_name]
```

**Usage:**
```python
# Switch layouts easily
viz = ConeVisualizer(config=VisualizationConfig('four_panel_grid'))
```

---

### Phase 4: Base Panel Class

Enforce consistency across all panels:

```python
# base_panel.py
from abc import ABC, abstractmethod

class BasePanel(ABC):
    """Abstract base class for all panels."""
    
    def __init__(self):
        self.colors = {}
        self.config = {}
    
    @abstractmethod
    def add_to_figure(self, fig, data, row, col):
        """Add traces to the figure."""
        pass
    
    @abstractmethod
    def validate_data(self, data):
        """Validate input data before plotting."""
        pass
    
    def add_legend(self, fig, row, col, position='bottom_left'):
        """Optional: Add legend/annotations."""
        pass
```

**All panels inherit from this:**
```python
class ProbabilityConePanel(BasePanel):
    def add_to_figure(self, fig, data, row, col):
        # Must implement
        self.validate_data(data)
        # ... plotting logic
```

---

### Phase 5: Data Pipeline

Separate data fetching from visualization:

```python
# data_pipeline.py
class DataPipeline:
    """Fetch and prepare all data before visualization."""
    
    def __init__(self):
        self.fetcher = UnifiedDataFetcher()
        self.cache = {}
    
    def fetch_all(self, config):
        """Fetch all required data based on config."""
        return {
            'spx': self._fetch_spx(config),
            'vix': self._fetch_vix(config),
            'iv_rv': self._fetch_iv_rv(config),
            'greeks': self._fetch_greeks(config),  # Future
        }
    
    def _fetch_spx(self, config):
        # Cache to avoid re-fetching
        if 'spx' not in self.cache:
            self.cache['spx'] = self.fetcher.fetch_spx(...)
        return self.cache['spx']
```

**Usage in visualizer:**
```python
class ConeVisualizer:
    def __init__(self):
        self.pipeline = DataPipeline()
    
    def plot_decision_chart(self):
        # Fetch all data upfront
        data = self.pipeline.fetch_all(self.config)
        
        # Pass to panels
        self.cone_panel.add_to_figure(fig, data['spx'], ...)
        self.vix_panel.add_to_figure(fig, data['vix'], ...)
```

---

### Phase 6: Interactive Features

Add user controls without breaking existing code:

```python
# interactive_controls.py
class InteractiveControls:
    """Add buttons, sliders, dropdowns to the visualization."""
    
    @staticmethod
    def add_vix_slider(fig):
        """Add slider to change VIX level."""
        fig.update_layout(
            sliders=[{
                'active': 0,
                'steps': [
                    {'label': f'VIX {v}', 'method': 'restyle', 'args': [...]}
                    for v in range(10, 50, 5)
                ]
            }]
        )
    
    @staticmethod
    def add_panel_toggles(fig):
        """Add buttons to show/hide panels."""
        fig.update_layout(
            updatemenus=[{
                'buttons': [
                    {'label': 'Show All', 'method': 'restyle', 'args': [{'visible': True}]},
                    {'label': 'Panel 1 Only', 'method': 'restyle', 'args': [...]},
                ]
            }]
        )
```

---

## üìã Recommended File Structure

```
visualization/
‚îÇ
‚îú‚îÄ‚îÄ config.py                  # All configuration
‚îú‚îÄ‚îÄ layouts.py                 # Layout presets
‚îÇ
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ base_panel.py         # Abstract base class
‚îÇ   ‚îú‚îÄ‚îÄ annotation_manager.py # Annotation utilities
‚îÇ   ‚îú‚îÄ‚îÄ data_pipeline.py      # Data fetching/caching
‚îÇ   ‚îî‚îÄ‚îÄ interactive_controls.py
‚îÇ
‚îú‚îÄ‚îÄ panels/
‚îÇ   ‚îú‚îÄ‚îÄ panel_cone.py
‚îÇ   ‚îú‚îÄ‚îÄ panel_vix_landscape.py
‚îÇ   ‚îú‚îÄ‚îÄ panel_iv_rv.py
‚îÇ   ‚îú‚îÄ‚îÄ panel_greeks.py       # Future
‚îÇ   ‚îî‚îÄ‚îÄ panel_term_structure.py  # Future
‚îÇ
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ UnifiedDataFetcher.py
‚îÇ
‚îî‚îÄ‚îÄ visualizer.py             # Orchestrator (main entry)
```

---

## üõ°Ô∏è Best Practices for Adding New Features

### ‚úÖ DO:
1. **Add new panels as separate files** - Keep them modular
2. **Use the config class** - Don't hardcode settings
3. **Test with existing panels** - Make sure nothing breaks
4. **Document parameters** - Clear docstrings
5. **Use consistent naming** - Follow existing patterns

### ‚ùå DON'T:
1. **Don't modify core layout logic** without testing all panels
2. **Don't hardcode dimensions** - Use config values
3. **Don't create dependencies between panels** - Keep them independent
4. **Don't bypass the annotation system** - Use consistent methods
5. **Don't mix data fetching with plotting** - Separate concerns

---

## üéì Example: Adding Panel 4 (Greeks Surface)

```python
# Step 1: Create the panel
# panels/panel_greeks.py
class GreeksPanel(BasePanel):
    def add_to_figure(self, fig, options_data, row, col):
        # Plot delta/gamma/theta surface
        pass

# Step 2: Update config
# config.py
class VisualizationConfig:
    LAYOUT = {
        'rows': 4,  # Added one more row
        'row_heights': [0.30, 0.20, 0.25, 0.25],
    }
    
    PANEL_4 = {
        'show_legend': True,
        'show_3d': False,  # Toggle 3D surface
    }

# Step 3: Wire it up
# visualizer.py
class ConeVisualizer:
    def __init__(self):
        self.greeks_panel = GreeksPanel()
    
    def plot_decision_chart(self):
        # ... existing panels ...
        
        # Add Panel 4
        if hasattr(self, 'greeks_panel'):
            options_data = self.fetcher.fetch_options_chain()
            fig = self.greeks_panel.add_to_figure(
                fig, options_data, row=4, col=1
            )
```

**That's it!** Existing panels are unaffected.

---

## üí° Key Takeaway

The structure is now set up so you can:
- **Add new panels** without touching old ones
- **Toggle features** via config
- **Maintain consistency** across all visualizations
- **Scale to 10+ panels** without chaos

Each panel is a self-contained module that just needs:
1. `add_to_figure()` method
2. Entry in config
3. One line in visualizer to call it

**This is the foundation for a professional, maintainable codebase!** üöÄ